<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Geodesic Half-Dome with Wave Collider</title>
<style>
  body { margin:0; overflow:hidden; }
  .collisionOverlay {
    position: absolute; top: 0; width: 350px; height: 100vh; overflow: hidden;
    font-family: monospace; font-size: 15px; padding: 8px; pointer-events: none; z-index: 10;
    display: flex; flex-direction: column;
  }
  #collisionOverlay1 { right: 0; }
  #collisionOverlay2 { left: 0; margin-left: 70px; }
  .collisionOverlay .collisionList { flex: 1; overflow-y: hidden; }
  .collisionOverlay div { pointer-events: none; }
</style>
</head>
<body>
<div id="collisionOverlay1" class="collisionOverlay"></div>
<div id="collisionOverlay2" class="collisionOverlay"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
// ===== Scene & Camera =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const radius = 6;
const detail = 3;

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(radius*2, radius/2, radius*2);
camera.lookAt(0, radius/2, 0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===== Lights =====
scene.add(new THREE.AmbientLight(0xffffff,0.5));
const light = new THREE.DirectionalLight(0xffffff, 0.8);
light.position.set(radius*3, radius*3, radius*3);
scene.add(light);

// ===== Geodesic Half-Dome =====
const geo = new THREE.IcosahedronGeometry(radius, detail);
const vertices = geo.attributes.position;
for (let i=0; i<vertices.count; i++){
  if (vertices.getY(i) < 0) vertices.setY(i, 0); // half-dome
}
vertices.needsUpdate = true;

const domeMat = new THREE.MeshPhongMaterial({color:0x00ccff, wireframe:true});
const dome = new THREE.Mesh(geo, domeMat);
scene.add(dome);

// ===== Bottom Mask =====
const maskRadius = radius * 1.05;
const maskGeo = new THREE.CircleGeometry(maskRadius, 64);
const maskMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
const mask = new THREE.Mesh(maskGeo, maskMat);
mask.rotation.x = -Math.PI/2;
mask.position.y = 0;
scene.add(mask);

// ===== Precompute Dome Triangles (baseline) =====
const domeTriangles = [];
for (let i = 0; i < vertices.count; i += 3){
  const a = new THREE.Vector3().fromBufferAttribute(vertices, i);
  const b = new THREE.Vector3().fromBufferAttribute(vertices, i+1);
  const c = new THREE.Vector3().fromBufferAttribute(vertices, i+2);
  domeTriangles.push(new THREE.Triangle(a.clone(), b.clone(), c.clone()));
}

// ===== Fill Meshes =====
const fillGroup = new THREE.Group();
scene.add(fillGroup);
const fillMats = [];

for (let tri of domeTriangles){
  const geom = new THREE.BufferGeometry();
  const verts = new Float32Array([
    tri.a.x, tri.a.y, tri.a.z,
    tri.b.x, tri.b.y, tri.b.z,
    tri.c.x, tri.c.y, tri.c.z
  ]);
  geom.setAttribute('position', new THREE.BufferAttribute(verts, 3));

  const mat = new THREE.MeshPhongMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.0,
    side: THREE.DoubleSide
  });
  fillMats.push(mat);

  const mesh = new THREE.Mesh(geom, mat);
  fillGroup.add(mesh);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ===== Economical Extruded Wave (volume; depth = dome diameter) =====

const waveLength = 20;                // X-length of the wave
const waveDepth  = 2 * radius;        // width along Z (diameter of the dome)
const wavePeak   = radius * 1.1;      // peak height
const wedgeThickness = 0.2;           // base thickness

// Build both the Shape **and** the 2D outline array we can reuse for point-in-polygon
function buildWaveShapeAndOutline(L, A, base=0, samples=17) {
  const top = [];
  for (let i = 0; i < samples; i++) {
    const t = i / (samples - 1);
    const x = t * L;
    const y = base + A * Math.sin(Math.PI * t);
    top.push(new THREE.Vector2(x, y));
  }
  const outline = [
    new THREE.Vector2(0, base),
    ...top,
    new THREE.Vector2(L, base - wedgeThickness),
    new THREE.Vector2(0,  base - wedgeThickness),
  ];
  const shape = new THREE.Shape(outline);
  return { shape, outline };
}

const { shape: waveShape, outline: waveOutline2D } = buildWaveShapeAndOutline(waveLength, wavePeak, 0, 17);

// Materials
const capMat  = new THREE.MeshBasicMaterial({ color: 0x00ffaa, transparent: true, opacity: 0.5 }); // front/back
const sideMat = new THREE.MeshBasicMaterial({ color: 0x00ccff, transparent: true, opacity: 0.35 }); // sides

const waveGeo = new THREE.ExtrudeGeometry(waveShape, {
  depth: waveDepth,
  bevelEnabled: false,
  steps: 1
});
waveGeo.computeVertexNormals();

const waveMesh = new THREE.Mesh(waveGeo, [sideMat, capMat]);
scene.add(waveMesh);

// ===== Placement =====
waveMesh.rotation.y = Math.PI; // face the dome
{
  const waveBox = new THREE.Box3().setFromObject(waveMesh);
  waveMesh.position.y = -waveBox.min.y;
  const waveCenter = new THREE.Vector3(); waveBox.getCenter(waveCenter);
  waveMesh.position.x -= waveCenter.x;
  waveMesh.position.z -= waveCenter.z;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ===== Overlay =====
const overlay1 = document.getElementById('collisionOverlay1');
const header1 = document.createElement('div');
header1.textContent = 'CandyWash_01.MP4';
header1.style.fontWeight = 'bold';
header1.style.fontSize = '20px';
header1.style.color = 'rgba(0,255,170,0.6)';
header1.style.marginTop = '50px';
overlay1.appendChild(header1);

const collisionList1 = document.createElement('div');
collisionList1.className = 'collisionList';
overlay1.appendChild(collisionList1);

// Precompute dome triangle AABBs once (outside animate) – still useful for early reject
const domeTrianglesBoxes = domeTriangles.map(tri => {
  const box = new THREE.Box3();
  box.setFromPoints([tri.a, tri.b, tri.c]);
  return box;
});

// --------- Point-in-polygon (even–odd rule) for 2D outline ----------
function pointInPoly(poly, p) {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i].x, yi = poly[i].y;
    const xj = poly[j].x, yj = poly[j].y;
    const intersect = ((yi > p.y) !== (yj > p.y)) &&
                      (p.x < ( (xj - xi) * (p.y - yi) / ((yj - yi) || 1e-12) + xi ));
    if (intersect) inside = !inside;
  }
  return inside;
}

// ===== Reusable temps =====
const invWave = new THREE.Matrix4();
const aL = new THREE.Vector3(), bL = new THREE.Vector3(), cL = new THREE.Vector3();
const p2 = new THREE.Vector2();
const waveAABB = new THREE.Box3();
const EPS_Z = 1e-4; // tiny slab tolerance

function vertInsideWaveExtrusion(vLocal) {
  // tolerant slab check and 2D polygon check
  if (vLocal.z < -EPS_Z || vLocal.z > waveDepth + EPS_Z) return false;
  p2.set(vLocal.x, vLocal.y);
  return pointInPoly(waveOutline2D, p2);
}

// Test if edge AB crosses z = zPlane in wave-local space; if so, check XY against outline
function edgePlaneHit(A, B, zPlane) {
  const dz = B.z - A.z;
  if (Math.abs(dz) < 1e-9) return false; // parallel or coincident
  const t = (zPlane - A.z) / dz;
  if (t < -EPS_Z || t > 1 + EPS_Z) return false; // intersection not within segment
  const x = A.x + t * (B.x - A.x);
  const y = A.y + t * (B.y - A.y);
  p2.set(x, y);
  return pointInPoly(waveOutline2D, p2);
}

function animate() {
  requestAnimationFrame(animate);
  const t = Date.now() * 0.0015;

  // Wave slides across dome
  const slideDistance = radius * 4.4;
  waveMesh.position.x = Math.cos(t * 0.4) * slideDistance;

  // Reset fills
  for (let mat of fillMats) { mat.opacity = 0.0; mat.color.set(0xffffff); }

  // Update wave transforms and its AABB (broad-phase)
  waveMesh.updateMatrixWorld(true);
  invWave.copy(waveMesh.matrixWorld).invert();
  waveAABB.setFromObject(waveMesh);

  const collisions = [];

  for (let i = 0; i < domeTriangles.length; i++) {
    const tri = domeTriangles[i];
    const triBox = domeTrianglesBoxes[i];

    // Cheap reject: triangle AABB vs wave AABB
    if (!waveAABB.intersectsBox(triBox)) continue;

    // Transform triangle vertices into WAVE LOCAL SPACE
    aL.copy(tri.a).applyMatrix4(invWave);
    bL.copy(tri.b).applyMatrix4(invWave);
    cL.copy(tri.c).applyMatrix4(invWave);

    // Vertex-inside OR edge crossing the back/front cap with XY inside outline
    const hit =
      vertInsideWaveExtrusion(aL) ||
      vertInsideWaveExtrusion(bL) ||
      vertInsideWaveExtrusion(cL) ||
      edgePlaneHit(aL, bL, 0) || edgePlaneHit(bL, cL, 0) || edgePlaneHit(cL, aL, 0) ||               // back cap (z=0)
      edgePlaneHit(aL, bL, waveDepth) || edgePlaneHit(bL, cL, waveDepth) || edgePlaneHit(cL, aL, waveDepth); // front cap

    if (hit) {
      fillMats[i].opacity = 0.4;
      fillMats[i].color.set(0xffff00);
      collisions.push(`Triangle ${i}`);
    }
  }

  // Overlay
  const time = (Date.now() * 0.001).toFixed(4);
  collisionList1.innerHTML = '';
  for (let c of collisions) {
    const div = document.createElement('div');
    div.textContent = `${c} — ${time}s`;
    div.style.color = 'rgba(0,255,170,0.6)';
    collisionList1.appendChild(div);
  }

  renderer.render(scene, camera);
}

animate();

// ===== Resize =====
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
